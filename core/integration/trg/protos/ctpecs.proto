syntax = "proto3";
package ctpd;
option go_package = "protos;ctpecs";

// ctpd interface for ECS
service CTPd {
// Subscribe stream: AliECS calls this function on startup and again every time the connection is dropped on the CTPd side. In other
// words, we assume that this stream is active throughout the lifetime of AliECS and CTPd, and it is automatically reconnected as needed.
  rpc Subscribe (SubscribeRequest) returns (stream CtpEvent) {}
// global run:
  rpc RunLoad   (RunLoadRequest) returns (RunReply) {}
  rpc RunUnload (RunStopRequest) returns (RunReply) {}
// stdalone and global runs:
  rpc RunStart  (RunStartRequest) returns (RunReply) {}
  rpc RunStatus (RunStatusRequest) returns (RunReply) {}
  rpc RunList   (Empty) returns (RunReply) {}
  rpc RunStop   (RunStopRequest) returns (RunReply) {}
  rpc RunConfig (RunStopRequest) returns (RunReply) {}
}

// Empty payload, shouldn't really require any params as we only need this for the handler function in the CTPd server to be called.
// To be discussed: whether to include stream heartbeat frequency in this request.
message SubscribeRequest {}

// Proposal: in the Subscribe handler, the CTPd server:
// 1) sends a first CtpEvent message with msg = "SUBSCRIBED" and run number 0 or something like that (to be discussed)
// 2) every few seconds (configurable), the CTPd server pushes a CtpEvent, one for each active run; this is like a heartbeat
// 3) if and when a trigger session has stopped for any reason (fixed number of triggers reached, or any other condition
//    arising from the trigger system), the CTPd server pushes a CtpEvent, with the run number of the session that's stopping,
//    and msg = "END_OF_TRIGGER" or something like that to identify this event as an "end of trigger" condition. Another
//    option (alternative to msg="END_OF_TRIGGER") could be to define an enum type here in the Protofile, including all
//    RunStatus values plus a special value to say we've reached the maximum number of triggers for this session (to be discussed).
message CtpEvent {
  uint32 runn = 1;
  int32 rc = 1;   // 0: ok
                  // RunStatus rc: 0:active/running 1:paused 2:loaded 3:does not exist 
  string msg = 3; // general status field
}
//import "ctpecs_m.proto";
// global runs only:
message RunLoadRequest {
 uint32 runn = 1; // run number 
 string config = 2; 
 // -config, i.e. the content of partname.pd
 // -partname -the content is in ctp config dir partname.pd
 // -key in case the config is available in Consul[key]
 string detectors= 3;   // available detectors, "" -all required must be ready
}
// global + stdalone runs (common for ctpd/ltud):
message RunStartRequest {
 uint32 runn = 1; // run number 
 string config = 2; 
 // -config, e.g. "trig\nPH_bc 100 inf" or
 // -key in case the config is available in Consul[key]
 // -"" use default configuration
 //
 // Optional parameters follows, overriding parameters in config string
 // for the begining let's agree on three parameters :
 enum Mode {
 NULL = 0;         // use default (from config)
 TRIG = 1;
 CONT = 2;
 }
 Mode mode = 3;
 string ph_bc = 4; // BC-downscaled rate of physics triggers
 string ph_rnd = 5; // rate of physics triggers generated randomly
 // ph_ ...: "": use default (from config)
 //          N : number of BCs between 2 triggers
 //          2.3khz  rate of triggers: 2.3 khz
 string detector = 6;  // detector has to be given for stdalone runs, "" for global run
}
message RunStatusRequest {
  uint32 runn = 1;
}
message Empty {}
message RunStopRequest {
  uint32 runn = 1;
  string detector = 2;  // only for stdalone runs (forced stop)
}
message RunReply {   
  int32 rc = 1;   // 0: ok
// RunStatus rc: 0:active/running 1:paused 2:loaded 3:does not exist 
  string msg = 2; // response (usually "" when rc is 0)
}
