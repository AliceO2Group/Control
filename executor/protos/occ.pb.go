// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protos/occ.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StateChangeTrigger int32

const (
	StateChangeTrigger_EXECUTOR           StateChangeTrigger = 0
	StateChangeTrigger_DEVICE_INTENTIONAL StateChangeTrigger = 1
	StateChangeTrigger_DEVICE_ERROR       StateChangeTrigger = 2
)

var StateChangeTrigger_name = map[int32]string{
	0: "EXECUTOR",
	1: "DEVICE_INTENTIONAL",
	2: "DEVICE_ERROR",
}

var StateChangeTrigger_value = map[string]int32{
	"EXECUTOR":           0,
	"DEVICE_INTENTIONAL": 1,
	"DEVICE_ERROR":       2,
}

func (x StateChangeTrigger) String() string {
	return proto.EnumName(StateChangeTrigger_name, int32(x))
}

func (StateChangeTrigger) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{0}
}

type StateType int32

const (
	StateType_STATE_STABLE       StateType = 0
	StateType_STATE_INTERMEDIATE StateType = 1
)

var StateType_name = map[int32]string{
	0: "STATE_STABLE",
	1: "STATE_INTERMEDIATE",
}

var StateType_value = map[string]int32{
	"STATE_STABLE":       0,
	"STATE_INTERMEDIATE": 1,
}

func (x StateType) String() string {
	return proto.EnumName(StateType_name, int32(x))
}

func (StateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{1}
}

type DeviceEventType int32

const (
	DeviceEventType_NULL_DEVICE_EVENT DeviceEventType = 0
	DeviceEventType_END_OF_DATA       DeviceEventType = 1
)

var DeviceEventType_name = map[int32]string{
	0: "NULL_DEVICE_EVENT",
	1: "END_OF_DATA",
}

var DeviceEventType_value = map[string]int32{
	"NULL_DEVICE_EVENT": 0,
	"END_OF_DATA":       1,
}

func (x DeviceEventType) String() string {
	return proto.EnumName(DeviceEventType_name, int32(x))
}

func (DeviceEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{2}
}

type StateStreamRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StateStreamRequest) Reset()         { *m = StateStreamRequest{} }
func (m *StateStreamRequest) String() string { return proto.CompactTextString(m) }
func (*StateStreamRequest) ProtoMessage()    {}
func (*StateStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{0}
}
func (m *StateStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateStreamRequest.Merge(m, src)
}
func (m *StateStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateStreamRequest proto.InternalMessageInfo

type StateStreamReply struct {
	Type                 StateType `protobuf:"varint,1,opt,name=type,proto3,enum=occ_pb.StateType" json:"type,omitempty"`
	State                string    `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *StateStreamReply) Reset()         { *m = StateStreamReply{} }
func (m *StateStreamReply) String() string { return proto.CompactTextString(m) }
func (*StateStreamReply) ProtoMessage()    {}
func (*StateStreamReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{1}
}
func (m *StateStreamReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateStreamReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateStreamReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateStreamReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateStreamReply.Merge(m, src)
}
func (m *StateStreamReply) XXX_Size() int {
	return m.Size()
}
func (m *StateStreamReply) XXX_DiscardUnknown() {
	xxx_messageInfo_StateStreamReply.DiscardUnknown(m)
}

var xxx_messageInfo_StateStreamReply proto.InternalMessageInfo

func (m *StateStreamReply) GetType() StateType {
	if m != nil {
		return m.Type
	}
	return StateType_STATE_STABLE
}

func (m *StateStreamReply) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

type EventStreamRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventStreamRequest) Reset()         { *m = EventStreamRequest{} }
func (m *EventStreamRequest) String() string { return proto.CompactTextString(m) }
func (*EventStreamRequest) ProtoMessage()    {}
func (*EventStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{2}
}
func (m *EventStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStreamRequest.Merge(m, src)
}
func (m *EventStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventStreamRequest proto.InternalMessageInfo

type DeviceEvent struct {
	Type                 DeviceEventType `protobuf:"varint,1,opt,name=type,proto3,enum=occ_pb.DeviceEventType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DeviceEvent) Reset()         { *m = DeviceEvent{} }
func (m *DeviceEvent) String() string { return proto.CompactTextString(m) }
func (*DeviceEvent) ProtoMessage()    {}
func (*DeviceEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{3}
}
func (m *DeviceEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceEvent.Merge(m, src)
}
func (m *DeviceEvent) XXX_Size() int {
	return m.Size()
}
func (m *DeviceEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceEvent.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceEvent proto.InternalMessageInfo

func (m *DeviceEvent) GetType() DeviceEventType {
	if m != nil {
		return m.Type
	}
	return DeviceEventType_NULL_DEVICE_EVENT
}

type EventStreamReply struct {
	Event                *DeviceEvent `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *EventStreamReply) Reset()         { *m = EventStreamReply{} }
func (m *EventStreamReply) String() string { return proto.CompactTextString(m) }
func (*EventStreamReply) ProtoMessage()    {}
func (*EventStreamReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{4}
}
func (m *EventStreamReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStreamReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStreamReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStreamReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStreamReply.Merge(m, src)
}
func (m *EventStreamReply) XXX_Size() int {
	return m.Size()
}
func (m *EventStreamReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStreamReply.DiscardUnknown(m)
}

var xxx_messageInfo_EventStreamReply proto.InternalMessageInfo

func (m *EventStreamReply) GetEvent() *DeviceEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

type GetStateRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStateRequest) Reset()         { *m = GetStateRequest{} }
func (m *GetStateRequest) String() string { return proto.CompactTextString(m) }
func (*GetStateRequest) ProtoMessage()    {}
func (*GetStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{5}
}
func (m *GetStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStateRequest.Merge(m, src)
}
func (m *GetStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStateRequest proto.InternalMessageInfo

type GetStateReply struct {
	State                string   `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStateReply) Reset()         { *m = GetStateReply{} }
func (m *GetStateReply) String() string { return proto.CompactTextString(m) }
func (*GetStateReply) ProtoMessage()    {}
func (*GetStateReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{6}
}
func (m *GetStateReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStateReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStateReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStateReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStateReply.Merge(m, src)
}
func (m *GetStateReply) XXX_Size() int {
	return m.Size()
}
func (m *GetStateReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStateReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetStateReply proto.InternalMessageInfo

func (m *GetStateReply) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

type ConfigEntry struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigEntry) Reset()         { *m = ConfigEntry{} }
func (m *ConfigEntry) String() string { return proto.CompactTextString(m) }
func (*ConfigEntry) ProtoMessage()    {}
func (*ConfigEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{7}
}
func (m *ConfigEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigEntry.Merge(m, src)
}
func (m *ConfigEntry) XXX_Size() int {
	return m.Size()
}
func (m *ConfigEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigEntry proto.InternalMessageInfo

func (m *ConfigEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ConfigEntry) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type TransitionRequest struct {
	SrcState             string         `protobuf:"bytes,1,opt,name=srcState,proto3" json:"srcState,omitempty"`
	TransitionEvent      string         `protobuf:"bytes,2,opt,name=transitionEvent,proto3" json:"transitionEvent,omitempty"`
	Arguments            []*ConfigEntry `protobuf:"bytes,3,rep,name=arguments,proto3" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransitionRequest) Reset()         { *m = TransitionRequest{} }
func (m *TransitionRequest) String() string { return proto.CompactTextString(m) }
func (*TransitionRequest) ProtoMessage()    {}
func (*TransitionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{8}
}
func (m *TransitionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransitionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransitionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransitionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransitionRequest.Merge(m, src)
}
func (m *TransitionRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransitionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransitionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransitionRequest proto.InternalMessageInfo

func (m *TransitionRequest) GetSrcState() string {
	if m != nil {
		return m.SrcState
	}
	return ""
}

func (m *TransitionRequest) GetTransitionEvent() string {
	if m != nil {
		return m.TransitionEvent
	}
	return ""
}

func (m *TransitionRequest) GetArguments() []*ConfigEntry {
	if m != nil {
		return m.Arguments
	}
	return nil
}

type TransitionReply struct {
	Trigger              StateChangeTrigger `protobuf:"varint,1,opt,name=trigger,proto3,enum=occ_pb.StateChangeTrigger" json:"trigger,omitempty"`
	State                string             `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	TransitionEvent      string             `protobuf:"bytes,3,opt,name=transitionEvent,proto3" json:"transitionEvent,omitempty"`
	Ok                   bool               `protobuf:"varint,4,opt,name=ok,proto3" json:"ok,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TransitionReply) Reset()         { *m = TransitionReply{} }
func (m *TransitionReply) String() string { return proto.CompactTextString(m) }
func (*TransitionReply) ProtoMessage()    {}
func (*TransitionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_17fd8faceeeb3e6c, []int{9}
}
func (m *TransitionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransitionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransitionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransitionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransitionReply.Merge(m, src)
}
func (m *TransitionReply) XXX_Size() int {
	return m.Size()
}
func (m *TransitionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TransitionReply.DiscardUnknown(m)
}

var xxx_messageInfo_TransitionReply proto.InternalMessageInfo

func (m *TransitionReply) GetTrigger() StateChangeTrigger {
	if m != nil {
		return m.Trigger
	}
	return StateChangeTrigger_EXECUTOR
}

func (m *TransitionReply) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *TransitionReply) GetTransitionEvent() string {
	if m != nil {
		return m.TransitionEvent
	}
	return ""
}

func (m *TransitionReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func init() {
	proto.RegisterEnum("occ_pb.StateChangeTrigger", StateChangeTrigger_name, StateChangeTrigger_value)
	proto.RegisterEnum("occ_pb.StateType", StateType_name, StateType_value)
	proto.RegisterEnum("occ_pb.DeviceEventType", DeviceEventType_name, DeviceEventType_value)
	proto.RegisterType((*StateStreamRequest)(nil), "occ_pb.StateStreamRequest")
	proto.RegisterType((*StateStreamReply)(nil), "occ_pb.StateStreamReply")
	proto.RegisterType((*EventStreamRequest)(nil), "occ_pb.EventStreamRequest")
	proto.RegisterType((*DeviceEvent)(nil), "occ_pb.DeviceEvent")
	proto.RegisterType((*EventStreamReply)(nil), "occ_pb.EventStreamReply")
	proto.RegisterType((*GetStateRequest)(nil), "occ_pb.GetStateRequest")
	proto.RegisterType((*GetStateReply)(nil), "occ_pb.GetStateReply")
	proto.RegisterType((*ConfigEntry)(nil), "occ_pb.ConfigEntry")
	proto.RegisterType((*TransitionRequest)(nil), "occ_pb.TransitionRequest")
	proto.RegisterType((*TransitionReply)(nil), "occ_pb.TransitionReply")
}

func init() { proto.RegisterFile("protos/occ.proto", fileDescriptor_17fd8faceeeb3e6c) }

var fileDescriptor_17fd8faceeeb3e6c = []byte{
	// 603 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0xcd, 0x26, 0x6d, 0xbf, 0x74, 0xd2, 0xaf, 0x71, 0x96, 0x96, 0x86, 0x08, 0x45, 0x91, 0xa5,
	0x4a, 0xa1, 0x48, 0x06, 0x02, 0xbd, 0x00, 0xc1, 0x45, 0x9a, 0x2c, 0x55, 0xa4, 0x90, 0x48, 0x9b,
	0x6d, 0x85, 0xb8, 0x89, 0xdc, 0xd5, 0x92, 0x46, 0x4d, 0x6d, 0xe3, 0x6c, 0x2b, 0xf9, 0x1d, 0xb8,
	0x07, 0xde, 0x88, 0x4b, 0x1e, 0x01, 0x95, 0x17, 0x41, 0xbb, 0xfe, 0x89, 0x9d, 0x9a, 0x3b, 0xef,
	0xcc, 0xd9, 0x73, 0xce, 0xec, 0xcc, 0x18, 0x0c, 0xcf, 0x77, 0xa5, 0xbb, 0x7c, 0xe6, 0x72, 0x6e,
	0xe9, 0x4f, 0xbc, 0xe5, 0x72, 0x3e, 0xf5, 0x2e, 0xcc, 0x3d, 0xc0, 0x13, 0x69, 0x4b, 0x31, 0x91,
	0xbe, 0xb0, 0xaf, 0xa9, 0xf8, 0x72, 0x23, 0x96, 0xd2, 0x1c, 0x83, 0x91, 0x89, 0x7a, 0x8b, 0x00,
	0x1f, 0xc2, 0x86, 0x0c, 0x3c, 0x51, 0x47, 0x2d, 0xd4, 0xde, 0xed, 0xd4, 0xac, 0x90, 0xc0, 0xd2,
	0x38, 0x16, 0x78, 0x82, 0xea, 0x34, 0xde, 0x83, 0xcd, 0xa5, 0x0a, 0xd5, 0x8b, 0x2d, 0xd4, 0xde,
	0xa6, 0xe1, 0x41, 0xc9, 0x90, 0x5b, 0xe1, 0xc8, 0xac, 0xcc, 0x1b, 0xa8, 0xf4, 0xc5, 0xed, 0x9c,
	0x0b, 0x9d, 0xc3, 0x4f, 0x33, 0x0a, 0x07, 0xb1, 0x42, 0x0a, 0xb2, 0xd2, 0x31, 0xdf, 0x81, 0x91,
	0x61, 0x54, 0x16, 0x9f, 0xc0, 0xa6, 0x50, 0x31, 0xcd, 0x50, 0xe9, 0x3c, 0xc8, 0x61, 0xa0, 0x21,
	0xc2, 0xac, 0x41, 0xf5, 0x54, 0x48, 0x6d, 0x3e, 0x76, 0x73, 0x08, 0xff, 0xaf, 0x42, 0x8a, 0x2e,
	0x29, 0x05, 0xa5, 0x4b, 0x39, 0x86, 0x4a, 0xcf, 0x75, 0x3e, 0xcf, 0x67, 0xc4, 0x91, 0x7e, 0x80,
	0x0d, 0x28, 0x5d, 0x89, 0x20, 0x82, 0xa8, 0x4f, 0x75, 0xed, 0xd6, 0x5e, 0xdc, 0x24, 0x2f, 0xa0,
	0x0f, 0xe6, 0x57, 0x04, 0x35, 0xe6, 0xdb, 0xce, 0x72, 0x2e, 0xe7, 0xae, 0x13, 0x69, 0xe2, 0x06,
	0x94, 0x97, 0x3e, 0x9f, 0xa4, 0x54, 0x92, 0x33, 0x6e, 0x43, 0x55, 0x26, 0x17, 0xb4, 0xf9, 0x88,
	0x71, 0x3d, 0x8c, 0x5f, 0xc0, 0xb6, 0xed, 0xcf, 0x6e, 0xae, 0x85, 0x23, 0x97, 0xf5, 0x52, 0xab,
	0x94, 0xae, 0x3d, 0xe5, 0x95, 0xae, 0x50, 0xe6, 0x37, 0x04, 0xd5, 0xb4, 0x1d, 0x55, 0xef, 0x2b,
	0xf8, 0x4f, 0xfa, 0xf3, 0xd9, 0x4c, 0xf8, 0x51, 0x0b, 0x1a, 0x99, 0x26, 0xf7, 0x2e, 0x6d, 0x67,
	0x26, 0x58, 0x88, 0xa0, 0x31, 0x34, 0xbf, 0xe1, 0x79, 0xe6, 0x4b, 0xf9, 0xe6, 0x77, 0xa1, 0xe8,
	0x5e, 0xd5, 0x37, 0x5a, 0xa8, 0x5d, 0xa6, 0x45, 0xf7, 0xea, 0x68, 0x18, 0x4d, 0x64, 0x46, 0x0e,
	0xef, 0x40, 0x99, 0x7c, 0x24, 0xbd, 0x33, 0x36, 0xa6, 0x46, 0x01, 0x3f, 0x04, 0xdc, 0x27, 0xe7,
	0x83, 0x1e, 0x99, 0x0e, 0x46, 0x8c, 0x8c, 0xd8, 0x60, 0x3c, 0xea, 0x0e, 0x0d, 0x84, 0x0d, 0xd8,
	0x89, 0xe2, 0x84, 0xd2, 0x31, 0x35, 0x8a, 0x47, 0xc7, 0xb0, 0x9d, 0x4c, 0xa8, 0x4a, 0x4f, 0x58,
	0x97, 0x91, 0xe9, 0x84, 0x75, 0x4f, 0x86, 0x24, 0x24, 0x0a, 0x23, 0x8a, 0x87, 0x7e, 0x20, 0xfd,
	0x41, 0x97, 0x11, 0x03, 0x1d, 0xbd, 0x86, 0xea, 0xda, 0xd8, 0xe1, 0x7d, 0xa8, 0x8d, 0xce, 0x86,
	0xc3, 0x69, 0x2c, 0x70, 0x4e, 0x46, 0xcc, 0x28, 0xe0, 0x2a, 0x54, 0xc8, 0xa8, 0x3f, 0x1d, 0xbf,
	0x9f, 0xf6, 0xbb, 0xac, 0x6b, 0xa0, 0xce, 0x8f, 0x22, 0x94, 0xc6, 0x9c, 0xe3, 0x53, 0xa8, 0xa4,
	0x06, 0x14, 0x27, 0x6f, 0x79, 0x7f, 0x0f, 0x1a, 0xf5, 0xdc, 0x9c, 0xb7, 0x08, 0xcc, 0xc2, 0x73,
	0xa4, 0x88, 0x52, 0xcb, 0x88, 0xb3, 0x4d, 0xf9, 0x07, 0xd1, 0xfa, 0xf6, 0x6a, 0xa2, 0xb7, 0x50,
	0x8e, 0x07, 0x1c, 0x27, 0xdb, 0xb5, 0xb6, 0x05, 0x8d, 0xfd, 0xfb, 0x09, 0x7d, 0x1f, 0x9f, 0x00,
	0xac, 0x06, 0x06, 0x3f, 0x8a, 0x61, 0xf7, 0x66, 0xba, 0x71, 0x90, 0x97, 0xd2, 0x1c, 0x27, 0x9d,
	0x9f, 0x77, 0x4d, 0xf4, 0xeb, 0xae, 0x89, 0x7e, 0xdf, 0x35, 0xd1, 0xf7, 0x3f, 0xcd, 0x02, 0x3c,
	0xe6, 0x97, 0x16, 0x17, 0xbe, 0x63, 0xd9, 0x8b, 0x39, 0x17, 0x96, 0xdb, 0xb1, 0xb8, 0xeb, 0x48,
	0xdf, 0x5d, 0x28, 0x92, 0x4f, 0x45, 0xef, 0xe2, 0x62, 0x4b, 0xff, 0xb0, 0x5e, 0xfe, 0x0d, 0x00,
	0x00, 0xff, 0xff, 0x46, 0x7b, 0xff, 0x7c, 0xc4, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OccClient is the client API for Occ service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OccClient interface {
	// We have to have a notification stream because the FairMQDevice might transition
	// on its own for whatever reason.
	EventStream(ctx context.Context, in *EventStreamRequest, opts ...grpc.CallOption) (Occ_EventStreamClient, error)
	StateStream(ctx context.Context, in *StateStreamRequest, opts ...grpc.CallOption) (Occ_StateStreamClient, error)
	GetState(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateReply, error)
	Transition(ctx context.Context, in *TransitionRequest, opts ...grpc.CallOption) (*TransitionReply, error)
}

type occClient struct {
	cc *grpc.ClientConn
}

func NewOccClient(cc *grpc.ClientConn) OccClient {
	return &occClient{cc}
}

func (c *occClient) EventStream(ctx context.Context, in *EventStreamRequest, opts ...grpc.CallOption) (Occ_EventStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Occ_serviceDesc.Streams[0], "/occ_pb.Occ/EventStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &occEventStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Occ_EventStreamClient interface {
	Recv() (*EventStreamReply, error)
	grpc.ClientStream
}

type occEventStreamClient struct {
	grpc.ClientStream
}

func (x *occEventStreamClient) Recv() (*EventStreamReply, error) {
	m := new(EventStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *occClient) StateStream(ctx context.Context, in *StateStreamRequest, opts ...grpc.CallOption) (Occ_StateStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Occ_serviceDesc.Streams[1], "/occ_pb.Occ/StateStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &occStateStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Occ_StateStreamClient interface {
	Recv() (*StateStreamReply, error)
	grpc.ClientStream
}

type occStateStreamClient struct {
	grpc.ClientStream
}

func (x *occStateStreamClient) Recv() (*StateStreamReply, error) {
	m := new(StateStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *occClient) GetState(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateReply, error) {
	out := new(GetStateReply)
	err := c.cc.Invoke(ctx, "/occ_pb.Occ/GetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *occClient) Transition(ctx context.Context, in *TransitionRequest, opts ...grpc.CallOption) (*TransitionReply, error) {
	out := new(TransitionReply)
	err := c.cc.Invoke(ctx, "/occ_pb.Occ/Transition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OccServer is the server API for Occ service.
type OccServer interface {
	// We have to have a notification stream because the FairMQDevice might transition
	// on its own for whatever reason.
	EventStream(*EventStreamRequest, Occ_EventStreamServer) error
	StateStream(*StateStreamRequest, Occ_StateStreamServer) error
	GetState(context.Context, *GetStateRequest) (*GetStateReply, error)
	Transition(context.Context, *TransitionRequest) (*TransitionReply, error)
}

func RegisterOccServer(s *grpc.Server, srv OccServer) {
	s.RegisterService(&_Occ_serviceDesc, srv)
}

func _Occ_EventStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OccServer).EventStream(m, &occEventStreamServer{stream})
}

type Occ_EventStreamServer interface {
	Send(*EventStreamReply) error
	grpc.ServerStream
}

type occEventStreamServer struct {
	grpc.ServerStream
}

func (x *occEventStreamServer) Send(m *EventStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Occ_StateStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StateStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OccServer).StateStream(m, &occStateStreamServer{stream})
}

type Occ_StateStreamServer interface {
	Send(*StateStreamReply) error
	grpc.ServerStream
}

type occStateStreamServer struct {
	grpc.ServerStream
}

func (x *occStateStreamServer) Send(m *StateStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Occ_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OccServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/occ_pb.Occ/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OccServer).GetState(ctx, req.(*GetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Occ_Transition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OccServer).Transition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/occ_pb.Occ/Transition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OccServer).Transition(ctx, req.(*TransitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Occ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "occ_pb.Occ",
	HandlerType: (*OccServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetState",
			Handler:    _Occ_GetState_Handler,
		},
		{
			MethodName: "Transition",
			Handler:    _Occ_Transition_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EventStream",
			Handler:       _Occ_EventStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StateStream",
			Handler:       _Occ_StateStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/occ.proto",
}

func (m *StateStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StateStreamReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateStreamReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOcc(dAtA, i, uint64(m.Type))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EventStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeviceEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOcc(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EventStreamReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStreamReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOcc(dAtA, i, uint64(m.Event.Size()))
		n1, err1 := m.Event.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetStateReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStateReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransitionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransitionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SrcState) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.SrcState)))
		i += copy(dAtA[i:], m.SrcState)
	}
	if len(m.TransitionEvent) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.TransitionEvent)))
		i += copy(dAtA[i:], m.TransitionEvent)
	}
	if len(m.Arguments) > 0 {
		for _, msg := range m.Arguments {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOcc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransitionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransitionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Trigger != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOcc(dAtA, i, uint64(m.Trigger))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.TransitionEvent) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOcc(dAtA, i, uint64(len(m.TransitionEvent)))
		i += copy(dAtA[i:], m.TransitionEvent)
	}
	if m.Ok {
		dAtA[i] = 0x20
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintOcc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StateStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateStreamReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovOcc(uint64(m.Type))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovOcc(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventStreamReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovOcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStateReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransitionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcState)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	l = len(m.TransitionEvent)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovOcc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransitionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trigger != 0 {
		n += 1 + sovOcc(uint64(m.Trigger))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	l = len(m.TransitionEvent)
	if l > 0 {
		n += 1 + l + sovOcc(uint64(l))
	}
	if m.Ok {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOcc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOcc(x uint64) (n int) {
	return sovOcc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StateStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateStreamReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateStreamReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateStreamReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DeviceEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStreamReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStreamReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStreamReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &DeviceEvent{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStateReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransitionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransitionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransitionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionEvent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransitionEvent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, &ConfigEntry{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransitionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransitionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransitionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			m.Trigger = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Trigger |= StateChangeTrigger(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionEvent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransitionEvent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOcc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOcc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOcc
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthOcc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOcc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOcc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthOcc
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOcc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOcc   = fmt.Errorf("proto: integer overflow")
)
